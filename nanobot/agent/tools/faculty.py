
from nanobot.agent.tools.base import Tool
from typing import Any, List, Dict
import os
import logging
import json

logger = logging.getLogger(__name__)

class GrantForgeTool(Tool):
    """
    Tool for generating grant proposal drafts.
    """
    @property
    def name(self) -> str:
        return "grant_forge"

    @property
    def description(self) -> str:
        return "Generate a structured draft for a grant proposal based on topic and agency."

    @property
    def parameters(self) -> dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "topic": {"type": "string", "description": "Research topic or project title."},
                "agency": {"type": "string", "description": "Funding agency (e.g., NIH, NSF)."},
                "focus_area": {"type": "string", "description": "Specific focus area or RFA."}
            },
            "required": ["topic", "agency"]
        }

    async def execute(self, topic: str, agency: str, focus_area: str = "") -> str:
        # Mock implementation for now - in production this would call an LLM or use templates
        draft = f"""# Grant Proposal Draft: {topic}
## Agency: {agency}
## Focus: {focus_area}

### Specific Aims
1. Aim 1: Define the scope of...
2. Aim 2: Investigate the mechanism of...
3. Aim 3: Validate the findings using...

### Significance
This project addresses a critical gap in...

### Innovation
Our approach is novel because...

[Draft generated by GrantForge]
"""
        return draft

class SyllabusArchitectTool(Tool):
    """
    Tool for designing course syllabi.
    """
    @property
    def name(self) -> str:
        return "syllabus_architect"

    @property
    def description(self) -> str:
        return "Generate a course syllabus structure."

    @property
    def parameters(self) -> dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "course_title": {"type": "string", "description": "Title of the course."},
                "level": {"type": "string", "description": "Course level (e.g., Undergraduate, Graduate)."},
                "duration_weeks": {"type": "integer", "description": "Duration in weeks."}
            },
            "required": ["course_title"]
        }

    async def execute(self, course_title: str, level: str = "Graduate", duration_weeks: int = 12) -> str:
        syllabus = f"""# Syllabus: {course_title}
**Level:** {level}
**Duration:** {duration_weeks} Weeks

## Course Description
This course explores the fundamental principles of {course_title}...

## Weekly Schedule
"""
        for i in range(1, duration_weeks + 1):
            syllabus += f"- **Week {i}:** Topic {i} Overview\n"
            
        syllabus += "\n## Assessment\n- Midterm Exam (30%)\n- Final Project (40%)\n- Assignments (30%)"
        return syllabus

class NoteGathererTool(Tool):
    """
    Tool for aggregating lecture notes.
    """
    @property
    def name(self) -> str:
        return "note_gatherer"

    @property
    def description(self) -> str:
        return "Gather and organize lecture notes for a specific topic."

    @property
    def parameters(self) -> dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "topic": {"type": "string", "description": "Topic to gather notes on."},
                "sources": {"type": "array", "items": {"type": "string"}, "description": "List of sources (optional)."}
            },
            "required": ["topic"]
        }

    async def execute(self, topic: str, sources: List[str] = None) -> str:
        # Mocking note gathering
        notes = f"""# Lecture Notes: {topic}

## Key Concepts
- Concept A related to {topic}
- Concept B related to {topic}

## References
{', '.join(sources) if sources else 'Standard Textbooks'}

[Notes aggregated by NoteGatherer]
"""
        return notes

class SlideDeckBuilderTool(Tool):
    """
    Tool for generating PPTX slides.
    """
    @property
    def name(self) -> str:
        return "slide_deck_builder"

    @property
    def description(self) -> str:
        return "Generate a PowerPoint presentation from provided content/outline."

    @property
    def parameters(self) -> dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "title": {"type": "string", "description": "Presentation title."},
                "slides_content": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "title": {"type": "string"},
                            "points": {"type": "array", "items": {"type": "string"}}
                        }
                    },
                    "description": "List of slide objects with title and bullet points."
                },
                "output_path": {"type": "string", "description": "Output path for the PPTX file."}
            },
            "required": ["title", "slides_content", "output_path"]
        }

    async def execute(self, title: str, slides_content: List[Dict[str, Any]], output_path: str) -> str:
        try:
            from pptx import Presentation
            from pptx.util import Inches, Pt
        except ImportError:
            return "Error: python-pptx is not installed. Please install it to use this tool."

        prs = Presentation()

        # Title Slide
        title_slide_layout = prs.slide_layouts[0]
        slide = prs.slides.add_slide(title_slide_layout)
        title_placeholder = slide.shapes.title
        subtitle_placeholder = slide.placeholders[1]

        title_placeholder.text = title
        subtitle_placeholder.text = "Generated by BioDockify Faculty Agent"

        # Content Slides
        bullet_slide_layout = prs.slide_layouts[1]

        for slide_data in slides_content:
            slide = prs.slides.add_slide(bullet_slide_layout)
            shapes = slide.shapes
            title_shape = shapes.title
            body_shape = shapes.placeholders[1]

            title_shape.text = slide_data.get("title", "Untitled Slide")
            tf = body_shape.text_frame
            
            points = slide_data.get("points", [])
            if points:
                tf.text = points[0]
                for point in points[1:]:
                    p = tf.add_paragraph()
                    p.text = point
                    p.level = 0

        # Ensure directory exists
        os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)
        
        try:
            prs.save(output_path)
            return f"Successfully generated presentation at {output_path}"
        except Exception as e:
            return f"Error saving presentation: {str(e)}"
